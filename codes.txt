MITM

import socket
import random

p=23
g=5

alice_pvt=random.randint(1,p-1)
A=pow(g,alice_pvt,p)

sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.connect(('localhost',8080))

sock.send(str(A).encode()) #sending key to bob, but intercepted
B=int(sock.recv(1024).decode()) # receiving from bob actually eve

shared_secret_key=pow(B,alice_pvt,p)
print(f"Alice's key: {shared_secret_key}")

sock.close()

import socket
import random

p=23
g=5

bob_pvt=random.randint(1,p-1)
B=pow(g,bob_pvt,p)

server=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
server.bind(('localhost',9090))
server.listen(1)

conn,addr=server.accept()

A=int(conn.recv(1024).decode())
conn.send(str(B).encode())

shared_secret_key=pow(A,bob_pvt,p)
print(f"Bob's secret key is: {shared_secret_key}")

conn.close()
server.close()

import socket

p=23
g=5

alice_sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
alice_sock.bind(('localhost',8080))
alice_sock.listen(1)

conn,addr=alice_sock.accept()

A=int(conn.recv(1024).decode())
print(f"Intercepted got key from Alice: {A}")

#establish connection wit bob
bob_sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
bob_sock.connect(('localhost',9090))

bob_sock.send(str(A).encode())
B=int(bob_sock.recv(1024).decode())

print(f"Intercepted key from Bob: {B}")

conn.send(str(B).encode()) # sending to Alice bob's key
malice_private = 10  # Mallory's secret key
S_alice = pow(A, malice_private, p)  # Shared secret with Alice
S_bob = pow(B, malice_private, p)  # Shared secret with Bob

print(f"Mallory's secret with Alice: {S_alice}")
print(f"Mallory's secret with Bob: {S_bob}")

conn.close()
bob_sock.close()
------------------------------------------------------------------------------------
DES Simplified

import socket

def start_client():
    host = 'localhost'
    port = 12345
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((host, port))

    plaintext = input("Enter 8-bit plaintext in hexadecimal (e.g., A5): ")
    key = input("Enter 10-bit key in hexadecimal (e.g., 2A3): ")

    client_socket.send(plaintext.encode('utf-8'))
    client_socket.send(key.encode('utf-8'))

    ciphertext = client_socket.recv(1024).decode('utf-8')
    print(f"Ciphertext (hex): {ciphertext}")

    client_socket.close()

if __name__ == "__main__":
    start_client()

import socket

def permute(block, table):
    """Rearranges bits based on a given permutation table."""
    return [block[i - 1] for i in table]

def xor(bits1, bits2):
    """Performs bitwise XOR operation on two lists of bits."""
    return [b1 ^ b2 for b1, b2 in zip(bits1, bits2)]

def substitute(block, sbox):
    """Substitutes a 4-bit block using the given S-Box."""
    row = (block[0] << 1) | block[3]  # Row selection
    col = (block[1] << 1) | block[2]  # Column selection
    return [int(i) for i in format(sbox[row][col], '02b')]

def encrypt_8bit_DES(plaintext, key):
    """Performs Simplified DES (S-DES) encryption on an 8-bit plaintext using a 10-bit key."""
    # Step 1: Define required permutation tables
    IP = [2, 6, 3, 1, 4, 8, 5, 7]      # Initial Permutation
    IP_inv = [4, 1, 3, 5, 7, 2, 8, 6]  # Inverse Initial Permutation
    EP = [4, 1, 2, 3, 2, 3, 4, 1]      # Expansion Permutation
    P4 = [2, 4, 3, 1]                  # P4 Permutation
    P10 = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6]  # P10 Key Permutation
    P8 = [6, 3, 7, 4, 8, 5, 10, 9]     # P8 Key Selection
    
    # Step 2: Define S-Boxes
    S0 = [[1, 0, 3, 2],
          [3, 2, 1, 0],
          [0, 2, 1, 3],
          [3, 1, 3, 2]]
    
    S1 = [[0, 1, 2, 3],
          [2, 0, 1, 3],
          [3, 0, 1, 0],
          [2, 1, 0, 3]]
    
    # Step 3: Key Scheduling - Generate two subkeys (Key1 and Key2)
    def left_shift(key, shifts):
        return key[shifts:] + key[:shifts]
    
    key = permute(key, P10)  # Apply P10 permutation
    left, right = key[:5], key[5:]
    left, right = left_shift(left, 1), left_shift(right, 1)
    key1 = permute(left + right, P8)  # First subkey
    left, right = left_shift(left, 2), left_shift(right, 2)
    key2 = permute(left + right, P8)  # Second subkey
    
    # Step 4: Feistel function for encryption
    def fk(bits, subkey):
        left, right = bits[:4], bits[4:]
        expanded_right = permute(right, EP)  # Expansion Permutation
        xored = xor(expanded_right, subkey)  # XOR with subkey
        left_sbox = substitute(xored[:4], S0)  # S-Box Substitution
        right_sbox = substitute(xored[4:], S1)
        sbox_output = left_sbox + right_sbox
        p4_output = permute(sbox_output, P4)  # P4 Permutation
        return xor(left, p4_output) + right  # XOR with left half
    
    # Step 5: Initial Permutation
    plaintext = permute(plaintext, IP)
    
    # Step 6: First round using Key1
    temp = fk(plaintext, key1)
    
    # Step 7: Swap halves
    swapped = temp[4:] + temp[:4]
    
    # Step 8: Second round using Key2
    temp = fk(swapped, key2)
    
    # Step 9: Apply Inverse Initial Permutation
    ciphertext = permute(temp, IP_inv)
    return ciphertext

def start_server():
    """Starts the server to receive plaintext and key from client, encrypts it, and sends back ciphertext."""
    host = 'localhost'
    port = 12345
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((host, port))
    server_socket.listen(5)
    print("Server is listening...")
    
    while True:
        client_socket, addr = server_socket.accept()
        print(f"Connected to {addr}")
        
        # Step 1: Receive plaintext and key from client (hexadecimal format)
        plaintext = client_socket.recv(1024).decode('utf-8')
        key = client_socket.recv(1024).decode('utf-8')
        
        # Step 2: Convert hexadecimal input to binary lists
        plaintext = [int(bit) for bit in bin(int(plaintext, 16))[2:].zfill(8)]
        key = [int(bit) for bit in bin(int(key, 16))[2:].zfill(10)]
        
        # Step 3: Encrypt plaintext using S-DES
        ciphertext = encrypt_8bit_DES(plaintext, key)
        
        # Step 4: Convert ciphertext from binary to hexadecimal format
        ciphertext_hex = hex(int(''.join(map(str, ciphertext)), 2))[2:].upper()
        
        # Step 5: Send ciphertext back to client
        client_socket.send(ciphertext_hex.encode('utf-8'))
        
        client_socket.close()

if __name__ == "__main__":
    start_server()

------------------------------------------------------------------------------------
DSA 

import socket
import sympy

def sign(H_m,x,q,g,p):
    k=sympy.randprime(1,q-1)
    r=pow(g,k,p)%q
    k_inv=pow(k,-1,q)
    s=(k_inv*(H_m+x*r))%q
    return r,s


def client():
    c=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    c.connect(('localhost',12345))
    print("Connection established at port 12345.")

    #inputs
    p,q,g,x=map(int,input("Enter values of p,q,g: ").split(','))
    x=sympy.randprime(1,q-1)
    y=pow(g,x,p)
    msg=input("Enter your message to encrypt")
    H_m=hash(msg)

    r,s=sign(H_m,x,q,g,p)
    print(f"Message signed values are: r={r}, s={s}")
    signature=f"{r},{s},{H_m},{q},{y},{g},{p}"

    c.send(signature.encode())
    print("Data sent to the server, check verification status there:")
    c.close()

client()

import socket

def verifySignature(H_m,r,s,q,y,g,p):
    w=pow(s,-1,q)
    u1=(H_m*w)%q
    u2=(r*w)%q

    v=((pow(g,u1,p)*pow(y,u2,p))%p)%q
    return v==r

def server():
    serv=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    serv.bind(('localhost',12345))
    serv.listen(1)
    print("Server listening on 12345...")
    conn,addr=serv.accept()
    print(f"Connection established at: {addr}")

    r,s,H_m,q,y,g,p=map(int,conn.recv(1024).decode().split(','))
    isValid=verifySignature(H_m,r,s,q,y,g,p)
    print("Signature is valid!" if isValid else "Signature is invalid :(")
    conn.close()
    serv.close()

server()
-----------------------------------------------------------------------------------
RSA

import socket
import sympy

def encrypt(m,e,n):
    return pow(m,e,n)

def client():
    c=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    c.connect(('localhost',12345))
    print("Client connected to server")

    #take inputs->
    p,q=map(int,input("Enter the values for p,q: ").split(','))
    n=p*q
    phi=(p-1)*(q-1)
    e=sympy.randprime(1,phi-1)
    d=pow(e,-1,phi)

    public_key=f"{e},{n}"
    private_key=f"{d},{n}"

    msg=int(input("Enter the message you need to encrypt: "))
    encrypted_msg=encrypt(msg,e,n)
    data=f"{encrypted_msg},{d},{n}"
    print(f"Encrypted message is: {encrypted_msg}")

    c.send(data.encode())
    print("Sent data to server, wait for response there: ")
    c.close()

client()

import socket

def decrypt(c,d,n):
    return pow(c,d,n)

def server():
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.bind(('localhost',12345))
    s.listen(1)
    print("Server listening on port 12345...")
    conn,addr=s.accept()
    print(f"Connection established at: {addr}")

    data=conn.recv(1024).decode()
    c,d,n=map(int,data.split(','))
    m=decrypt(c,d,n)
    print(f"Decrypted message is: {m}, ending the established connection")

    conn.close()
    s.close()

server()
------------------------------------------------------------------------------------
DSA Using RSA

import socket
import sympy

def client():
    c=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    c.connect(('localhost',12345))
    print("Connection established at 12345")
    p,q=map(int,input("Enter the numbers p and q: ").split(','))
    n=p*q
    phi=(p-1)*(q-1)
    e=sympy.randprime(1,pow(2,10))
    d=pow(e,-1,phi)
    message=input("Enter the message you want to hash: ")
    h_m=71

    signature=pow(h_m,d,n)
    data=f"{signature},{h_m},{e},{n}"
    print(f"Signature value is: {signature} \n check on server side now...")

    c.send(data.encode())
    c.close()
client()
import socket

def decrypt(sign,og_Hash,e,n):
    res=pow(sign,e,n)
    return res==og_Hash

def server():
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.bind(('localhost',12345))
    s.listen(1)
    print("Server listening at port no: 12345")
    conn,addr=s.accept()
    print(f"Connection established at {addr}")

    sign,og_Hash,e,n=map(int,conn.recv(1024).decode().split(','))

    isValid=decrypt(sign,og_Hash,e,n)
    print("Signature id valid" if isValid else "Signature is invalid")
    conn.close()
    s.close()

server()
----------------------------------------------------------------
Cipher Techniques

def caesar_encrypt(text, shift):
    result = ''
    for char in text:
        if char.isalpha():
            base = ord('A') if char.isupper() else ord('a')
            result += chr((ord(char) - base + shift) % 26 + base)
        else:
            result += char
    return result

def caesar_decrypt(text, shift):
    return caesar_encrypt(text, -shift)

def vigenere_encrypt(text, key):
    result = ''
    key = key.lower()
    key_index = 0
    for char in text:
        if char.isalpha():
            base = ord('A') if char.isupper() else ord('a')
            k = ord(key[key_index % len(key)]) - ord('a')
            result += chr((ord(char) - base + k) % 26 + base)
            key_index += 1
        else:
            result += char
    return result

def vigenere_decrypt(text, key):
    result = ''
    key = key.lower()
    key_index = 0
    for char in text:
        if char.isalpha():
            base = ord('A') if char.isupper() else ord('a')
            k = ord(key[key_index % len(key)]) - ord('a')
            result += chr((ord(char) - base - k + 26) % 26 + base)
            key_index += 1
        else:
            result += char
    return result

def vernam_encrypt(text, key):
    if len(key) != len(text):
        raise ValueError("Key must be the same length as text for Vernam Cipher")
    result = ''
    for t, k in zip(text, key):
        result += chr(ord(t) ^ ord(k))
    return result

def vernam_decrypt(cipher, key):
    return vernam_encrypt(cipher, key)  # XOR again with same key

Hill Cipher

import socket
import numpy as np

def text_to_nums(text):
    return [ord(c.upper()) - ord('A') for c in text]

def nums_to_text(nums):
    return ''.join(chr(n % 26 + ord('A')) for n in nums)

def mod_inverse_matrix(matrix, mod):
    det = int(round(np.linalg.det(matrix))) % mod
    det_inv = pow(det, -1, mod)
    adjugate = np.round(det * np.linalg.inv(matrix)).astype(int) % mod
    return (det_inv * adjugate) % mod

def hill_encrypt(plain, key):
    vector = np.array(text_to_nums(plain)).reshape(-1, key.shape[0])
    encrypted = (key @ vector.T) % 26
    return nums_to_text(encrypted.T.flatten())

def hill_decrypt(cipher, key):
    inv_key = mod_inverse_matrix(key, 26)
    vector = np.array(text_to_nums(cipher)).reshape(-1, key.shape[0])
    decrypted = (inv_key @ vector.T) % 26
    return nums_to_text(decrypted.T.flatten())

key_matrix = np.array([[3, 2], [5, 7]])

server = socket.socket()
server.bind(('localhost', 9999))
server.listen(1)
print("Server listening...")

conn, addr = server.accept()
print("Connected to:", addr)

data = conn.recv(1024).decode()
mode, msg = data.split(":")

if len(msg) % 2 != 0:
    msg += 'X'  # Padding if odd-length

if mode == "ENC":
    result = hill_encrypt(msg, key_matrix)
else:
    result = hill_decrypt(msg, key_matrix)

conn.send(result.encode())
conn.close()

import socket

s = socket.socket()
s.connect(('localhost', 9999))

mode = input("Mode (ENC/DEC): ").strip().upper()
text = input("Text (multiple of 2 letters): ").strip().upper()

s.send(f"{mode}:{text}".encode())
print("Result:", s.recv(1024).decode())

s.close()
-------------------------------------------------------

MD5


import socket
import struct

def left_rotate(x, c):
    return ((x << c) | (x >> (32 - c))) & 0xFFFFFFFF

def md5(message):
    r = [7, 12, 17, 22] * 4 + [5, 9, 14, 20] * 4 + [4, 11, 16, 23] * 4 + [6, 10, 15, 21] * 4
    k = [int(2**32 * abs(__import__("math").sin(i + 1))) & 0xFFFFFFFF for i in range(64)]
    
    msg = bytearray(message, 'utf-8')
    orig_len = (8 * len(msg)) & 0xFFFFFFFFFFFFFFFF
    msg.append(0x80)
    while (len(msg) * 8) % 512 != 448:
        msg.append(0)
    msg += struct.pack('<Q', orig_len)

    a, b, c, d = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
    
    for i in range(0, len(msg), 64):
        chunk = msg[i:i + 64]
        w = list(struct.unpack('<16I', chunk))
        aa, bb, cc, dd = a, b, c, d
        for j in range(64):
            f, g = (b & c) | (~b & d), j if j < 16 else ((b & d) | (c & ~d), (5 * j + 1) % 16) if j < 32 else (b ^ c ^ d, (3 * j + 5) % 16) if j < 48 else (c ^ (b | ~d), (7 * j) % 16)
            f = (f + a + k[j] + w[g]) & 0xFFFFFFFF
            a, d, c, b = d, (b + left_rotate(f, r[j])) & 0xFFFFFFFF, b, c
        a, b, c, d = (a + aa) & 0xFFFFFFFF, (b + bb) & 0xFFFFFFFF, (c + cc) & 0xFFFFFFFF, (d + dd) & 0xFFFFFFFF

    return struct.pack('<4I', a, b, c, d).hex()

s = socket.socket()
s.connect(("127.0.0.1", 12345))
s.sendall(md5("hello").encode())
print(s.recv(1024).decode())
s.close()
import socket, struct

def left_rotate(x, c):
    return ((x << c) | (x >> (32 - c))) & 0xFFFFFFFF

def md5(message):
    r = [7, 12, 17, 22] * 4 + [5, 9, 14, 20] * 4 + [4, 11, 16, 23] * 4 + [6, 10, 15, 21] * 4
    k = [int(2**32 * abs(__import__("math").sin(i + 1))) & 0xFFFFFFFF for i in range(64)]
    
    msg = bytearray(message, 'utf-8')
    orig_len = (8 * len(msg)) & 0xFFFFFFFFFFFFFFFF
    msg.append(0x80)
    while (len(msg) * 8) % 512 != 448:
        msg.append(0)
    msg += struct.pack('<Q', orig_len)

    a, b, c, d = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
    
    for i in range(0, len(msg), 64):
        chunk = msg[i:i + 64]
        w = list(struct.unpack('<16I', chunk))
        aa, bb, cc, dd = a, b, c, d
        for j in range(64):
            f, g = (b & c) | (~b & d), j if j < 16 else ((b & d) | (c & ~d), (5 * j + 1) % 16) if j < 32 else (b ^ c ^ d, (3 * j + 5) % 16) if j < 48 else (c ^ (b | ~d), (7 * j) % 16)
            f = (f + a + k[j] + w[g]) & 0xFFFFFFFF
            a, d, c, b = d, (b + left_rotate(f, r[j])) & 0xFFFFFFFF, b, c
        a, b, c, d = (a + aa) & 0xFFFFFFFF, (b + bb) & 0xFFFFFFFF, (c + cc) & 0xFFFFFFFF, (d + dd) & 0xFFFFFFFF

    return struct.pack('<4I', a, b, c, d).hex()

server = socket.socket()
server.bind(("0.0.0.0", 12345))
server.listen(1)
print("Server listening on port 12345...")

while True:
    conn, addr = server.accept()
    data = conn.recv(1024).decode()
    print(f"Received: {data}")
    conn.sendall(md5(data).encode())
    conn.close()

--------------------------------------------------------
SHA-1

import socket
import threading

def left_rotate(n, b):
    return ((n << b) | (n >> (32 - b))) & 0xffffffff

def sha1(msg):
    msg = bytearray(msg, 'utf-8')
    ml = len(msg) * 8
    msg.append(0x80)
    while (len(msg) * 8) % 512 != 448:
        msg.append(0)
    msg += ml.to_bytes(8, 'big')

    h0, h1, h2, h3, h4 = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

    for i in range(0, len(msg), 64):
        w = list(int.from_bytes(msg[i + j:i + j + 4], 'big') for j in range(0, 64, 4))
        for j in range(16, 80):
            w.append(left_rotate(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1))

        a, b, c, d, e = h0, h1, h2, h3, h4

        for j in range(80):
            if j < 20: f, k = (b & c) | ((~b) & d), 0x5A827999
            elif j < 40: f, k = b ^ c ^ d, 0x6ED9EBA1
            elif j < 60: f, k = (b & c) | (b & d) | (c & d), 0x8F1BBCDC
            else: f, k = b ^ c ^ d, 0xCA62C1D6
            temp = (left_rotate(a, 5) + f + e + k + w[j]) & 0xffffffff
            a, b, c, d, e = temp, a, left_rotate(b, 30), c, d

        h0 = (h0 + a) & 0xffffffff
        h1 = (h1 + b) & 0xffffffff
        h2 = (h2 + c) & 0xffffffff
        h3 = (h3 + d) & 0xffffffff
        h4 = (h4 + e) & 0xffffffff

    return ''.join(hex(i)[2:].zfill(8) for i in [h0, h1, h2, h3, h4])

# ---------------- SERVER ---------------- #
def start_server():
    s = socket.socket()
    s.bind(("0.0.0.0", 12345))
    s.listen(1)
    print("[SERVER] Listening on port 12345...")
    while True:
        conn, addr = s.accept()
        data = conn.recv(1024).decode()
        print("[SERVER] Received:", data)
        digest = sha1(data)
        conn.sendall(digest.encode())
        conn.close()

# ---------------- CLIENT ---------------- #
def start_client(msg="hello"):
    s = socket.socket()
    s.connect(("127.0.0.1", 12345))
    s.sendall(msg.encode())
    print("[CLIENT] Sent:", msg)
    print("[CLIENT] SHA1:", s.recv(1024).decode())
    s.close()

--------------------------------------------------------
AES 

import socket

def pad(msg,b):
    n=len(msg)
    r=b-(n%b) if n%b else 0
    return msg+chr(r)*r

def unpad(msg):
    r=ord(msg[-1])
    return msg[:-r]

def xor_block(msg,key):
    return ''.join(chr(ord(m)^ord(k))for m,k in zip(msg,key))

def encrypt(msg,key):
    msg=pad(msg,len(key))
    out=""
    for i in range(0,len(msg),len(key)):
        blk=msg[i:i+len(key)]
        out+=xor_block(blk,key)
    return out.encode().hex()

def decrypt(cipher,key):
    raw=bytes.fromhex(cipher).decode()
    out=""
    for i in range(0,len(raw),len(key)):
        blk=raw[i:i+len(key)]
        out+=xor_block(blk,key)
    return unpad(out)

def server():
    k="simpleaeskey1234"
    s=socket.socket()
    s.bind(('localhost',9999))
    s.listen(1)
    c,_=s.accept()
    mode,data=c.recv(2048).decode().split(":",1)
    res=encrypt(data,k)if mode=="ENC"else decrypt(data,k)
    c.send(res.encode())
    c.close()


def client():
    s=socket.socket()
    s.connect(('localhost',9999))
    mode=input("Mode (ENC/DEC): ").strip().upper()
    text=input("Text: ").strip()
    s.send(f"{mode}:{text}".encode())
    print("Result:",s.recv(2048).decode())
    s.close()
